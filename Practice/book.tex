\documentclass[10pt,twoside,openany]{book}

\include{preamble}

\begin{document}

\include{title}
\include{titleback}

\tableofcontents

\clearpage

\chapter{std::vector}

\section{new[]/delete[] vs std::vector}

Перепишите следующую программу, используя {\tt std::vector}.

Последовательно избавьтесь от следующих конструкций:
\begin{itemize}
    \item Операторы {\tt new[]/delete[]} (переменные {\tt a} и {\tt b}
          превратите в объекты {\tt std::vector}.
    \item Переменная {\tt m} и цикл для вычисления её значения.
\end{itemize}

\lstinputlisting{sources/vector1.cpp}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Что делает исходная программа?
    \item Какие ограничения неявно наложены на значение переменной {\tt n}?
    \item На сколько строк удалось сократить исходный код, используя {\tt std::vector}?
    \item Когда освобождается память, используемая {\tt std::vector}?
\end{itemize}

\chapter{std::array}

\section{Массивы-значения}
\label{array-value}

Сравните две программы ниже. Предположите, какие значения выводятся в каждой из них,
а затем попробуйте запустить их и проверить результат.

\lstinputlisting{sources/array1.cpp}

\lstinputlisting{sources/array2.cpp}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Что выведут первая и вторая программы?
    \item Как можно было бы доработать вторую, чтобы получался такой же результат, как и в первой?
    \item Какое преимущество даёт использование {\tt std::array}?
    \item Что нужно изменить, чтобы не переделывать функцию {\tt sum} при изменении размера массива?
\end{itemize}

\chapter{std::list}

\section{Список вместо массива}

Проанализируйте следующую программу. Попробуйте выяснить, как время её работы растёт
с увеличением входного параметра $n$.

\lstinputlisting{sources/list1.cpp}

Перепишите программу с использованием контейнера {\tt std::list} вместо массива.
Для вставки значений в список используйте функцию {\tt std::list::insert}.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item В чём заключается ошибка программиста, который написал исходную программу?
    \item Какими способами можно просмотреть все элементы списка, чтобы вывести их на экран?
\end{itemize}

\chapter{Строки}

\section{Изограммы}

Изограмма --- это слово (или фраза), в котором не повторяются буквы.

Напишите программу, которая проверяет, является ли введённая строка изограммой.
Строка состоит из множества латинских букв в разном регистре, пробелов и знаков препинания.
Причём в изограмме пробелы или знаки препинания могут повторяться.

При реализации используйте следующие конструкции:
\begin{itemize}
    \item Функцию {\tt std::isalpha}
    \item Функцию {\tt std::tolower} или {\tt std::toupper}
\end{itemize}

\subsection*{Контрольные вопросы}

В вопросах подразумевается, что для входных данных используется кодировка ASCII.

\begin{itemize}
    \item Какой фрагмент кода мог бы заменить функцию {\tt std::isalpha}?
    \item Как можно реализовать функцию {\tt std::tolower}?
\end{itemize}

\section{Боб}

Боб не очень любит разговаривать, поэтому использует небольшой набор реплик.

Он отвечает <<Sure.>> на любой вопрос, например <<How are you?>>.

Он говорит <<Whoa, chill out!>>, если вы КРИЧИТЕ НА НЕГО (то есть используете одни заглавные буквы).

Он отвечает <<Calm down, I know what I'm doing!>> на вопрос, в котором вы кричите.

Он говорит <<Fine. Be that way!>> если вы обращаетесь к нему, но ничего
не говорите (это значит, что входная строка программы состоит из пробельных символов).

Он говорит <<Whatever.>> во всех остальных случаях.

Напишите диалоговую программу, которая имитирует разговор с Бобом. На каждую входную строку она
должна выводить такой ответ, какой давал бы Боб в такой же ситуации. Входные реплики для программы
должны подчиняться правилам пунктуации английского языка.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Каким способом проверяется, что все буквы во введённой строке заглавные?
    \item Какую функцию стандартной библиотеки можно использовать для проверки пробельных символов?
\end{itemize}

\section{Crypto square}

Implement the classic method for composing secret messages called a square code.

Given an English text, output the encoded version of that text.

First, the input is normalized: the spaces and punctuation are removed from the English text and the message is downcased.

Then, the normalized characters are broken into rows. These rows can be regarded as forming a rectangle when printed with intervening newlines.

For example, the sentence

"If man was meant to stay on the ground, god would have given us roots."
is normalized to:

"ifmanwasmeanttostayonthegroundgodwouldhavegivenusroots"
The plaintext should be organized in to a rectangle. The size of the rectangle (r x c) should be decided by the length of the message, such that c >= r and c - r <= 1, where c is the number of columns and r is the number of rows.

Our normalized text is 54 characters long, dictating a rectangle with c = 8 and r = 7:

"ifmanwas"
"meanttos"
"tayonthe"
"groundgo"
"dwouldha"
"vegivenu"
"sroots  "

The coded message is obtained by reading down the columns going left to right.

The message above is coded as:

"imtgdvsfearwermayoogoanouuiontnnlvtwttddesaohghnsseoau"
Output the encoded text in chunks that fill perfect rectangles (r X c), with c chunks of r length, separated by spaces. For phrases that are n characters short of the perfect rectangle, pad each of the last n chunks with a single trailing space.

"imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn  sseoau "
Notice that were we to stack these, we could visually decode the ciphertext back in to the original message:

"imtgdvs"
"fearwer"
"mayoogo"
"anouuio"
"ntnnlvt"
"wttddes"
"aohghn "
"sseoau "

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item
\end{itemize}

\section{Подстроки}

На входе в программу поступает строка из цифр и число $n$. Программа должна вывести все
непрерывные подстроки исходной строки длины $n$.

Например, для строки $49142$ и $n=3$ вывод будет таким: $491$, $914$, $142$.

А для $n=4$ таким: $4914$, $9142$.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Какую стандартную функцию можно использовать для получения подстрок?
\end{itemize}

\chapter{Алгоритмы}

\section{Сортировка}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item
\end{itemize}

\section{Двоичный поиск}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item
\end{itemize}

\section{std::accumulate}

Переделайте функции {\tt sum} в программах из задания~\ref{array-value},
используя алгоритм {\tt std::accumulate}.
Для этого потребуется подключить заголовочный файл {\tt numeric}.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Как переделать вызов {\tt std::accumulate}, чтобы вычислялась сумма элементов
          из первой половины массива?
\end{itemize}

\section{Снова std::accumulate}

Переделайте программы из предыдущего задания, чтобы вместо суммы функция {\tt std::accumulate} считала
произведение элементов.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Какое значение должно получиться, если в массиве не будет ни одного элемента?
\end{itemize}

\chapter{Структуры данных}

\section{Кольцевой буфер}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item
\end{itemize}

\chapter{Хеширование}

\section{Анаграммы}

Анаграмма --- это слово, полученное из исходного перестановкой букв.
Напишите программу, которая определяет, какие слова из списка являются анаграммами
заданного слова.

Например, для слова <<listen>> и списка <<enlists>>, <<google>>, <<inlets>>, <<banana>>
программа должна вывести список из одного элемента: <<inlets>>.

Предварительный отсев слов-кандидатов выполняйте с помощью вычисления
хеш-функции от этих строк.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Какую хеш-функцию вы выбрали?
    \item Можно ли для тех же целей использовать стандартную
          реализацию {\tt std::hash<std::string>}?
    \item Что кроме хеш-функции нужно использовать, чтобы убедиться, что буквы в строках совпадают?
\end{itemize}

\section{Коллизии}

Найти все анаграммы из слов-кандидатов для всех подмножеств букв из исходного слова.

Получить подмножества букв можно несколькими способами:
\begin{itemize}
    \item Рекурсивный перебор. На каждом шаге обрабатывается одна буква входного слова.
          Для каждого варианта (когда буква включается в результирующее слово и когда не включается)
          рекурсивный поиск продолжается со следующей буквой.
    \item Последовательно увеличивающиеся целые числа можно раскладывать на двоичные разряды.
          Каждый разряд сопоставляется одной букве. Если разряд $1$, то буква включается
          в результирующее подмножество.
\end{itemize}

Для хранения списка слов-кандидатов используйте контейнер {\tt std::unordered\_set}.
Этот контейнер использует хеширование для поиска и упорядочивания элементов.
Используйте второй параметр шаблона контейнера для указания собственной хеш-функции,
чтобы сравнивать строки без учёта порядка букв.
После генерации очередного подмножества букв можно проверять, если ли уже слово с такими
буквами в контейнере.

Проанализируйте, как часто возникают коллизии, если использовать только хеширование,
без сложной функции сравнения строк.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item С чем связано, что строки из разных букв могут получать одни и те же значения
          хеш-функции?
    \item Приведите пример двух строк из разных букв, но с одинаковым значением хеш-функции.
\end{itemize}

\chapter{std::map}

\section{Поиск}

Перепишите следующую программу, используя {\tt std::map}.

Выполните следующие действия:
\begin{itemize}
    \item Замените массивы {\tt word} и {\tt def} на переменную-контейнер {\tt std::map}.
    \item Замените алгоритм поиска на функцию {\tt find} контейнера {\tt std::map}.
\end{itemize}

\lstinputlisting{sources/map1.cpp}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Что делает исходная программа?
    \item Какой тип ключа применяется в использованном контейнере {\tt std::map}?
    \item Что возвращает функция {\tt find}, если нужный элемент не найден?
\end{itemize}

\section{Подсчёт слов}

Напишите программу, которая выводит сколько раз каждое слово из входной строки повторяется в ней.

Слова могут состоять из цифр и латинских букв. Слова с разным регистром букв считаются одинаковыми.
Знаки препинания, пробелы, переносы строк и символы табуляции нужно игнорировать.

\subsection*{Подзадачи}

\begin{itemize}
    \item Используйте {\tt std::map<std::string, int>} для хранения информации о количестве повторов.
    \item Попробуйте не считывать весь текст целиком, а читать по одному символу из входного потока.
    \item Напишите два варианта программы: с преобразованием хранимых в {\tt std::map} слов и без него.
          Для второго варианта замените функцию сравнения (третий параметр шаблона) на собственную.
\end{itemize}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Определён ли порядок элементов в {\tt std::map}? Можно ли его изменить?
\end{itemize}

\end{document}
