\documentclass[10pt,twoside,openany]{book}

\include{preamble}

\begin{document}

\include{title}
\include{titleback}

\tableofcontents

\clearpage

\chapter{std::vector}

\section{new[]/delete[] vs std::vector}

Перепишите следующую программу, используя {\tt std::vector}.

Последовательно избавьтесь от следующих конструкций:
\begin{itemize}
    \item Операторы {\tt new[]/delete[]} (переменные {\tt a} и {\tt b}
          превратите в объекты {\tt std::vector}.
    \item Переменная {\tt m} и цикл для вычисления её значения.
\end{itemize}

\lstinputlisting{sources/vector1.cpp}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Что делает исходная программа?
    \item Какие ограничения неявно наложены на значение переменной {\tt n}?
    \item На сколько строк удалось сократить исходный код, используя {\tt std::vector}?
    \item Когда освобождается память, используемая {\tt std::vector}?
\end{itemize}

\chapter{std::array}

\section{Массивы-значения}
\label{array-value}

Сравните две программы ниже. Предположите, какие значения выводятся в каждой из них,
а затем попробуйте запустить их и проверить результат.

\lstinputlisting{sources/array1.cpp}

\lstinputlisting{sources/array2.cpp}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Что выведут первая и вторая программы?
    \item Как можно было бы доработать вторую, чтобы получался такой же результат, как и в первой?
    \item Какое преимущество даёт использование {\tt std::array}?
    \item Что нужно изменить, чтобы не переделывать функцию {\tt sum} при изменении размера массива?
\end{itemize}

\chapter{std::list}

\chapter{Строки}

\section{Изограммы}

Изограмма --- это слово (или фраза), в котором не повторяются буквы.

Напишите программу, которая проверяет, является ли введённая строка изограммой.
Строка состоит из множества латинских букв в разном регистре, пробелов и знаков препинания.
Причём в изограмме пробелы или знаки препинания могут повторяться.

При реализации используйте следующие конструкции:
\begin{itemize}
    \item Функцию {\tt std::isalpha}
    \item Функцию {\tt std::tolower} или {\tt std::toupper}
\end{itemize}

\subsection*{Контрольные вопросы}

В вопросах подразумевается, что для входных данных используется кодировка ASCII.

\begin{itemize}
    \item Какой фрагмент кода мог бы заменить функцию {\tt std::isalpha}?
    \item Как можно реализовать функцию {\tt std::tolower}?
\end{itemize}

\section{Боб}

Боб не очень любит разговаривать, поэтому использует небольшой набор реплик.

Он отвечает <<Sure.>> на любой вопрос, например <<How are you?>>.

Он говорит <<Whoa, chill out!>>, если вы КРИЧИТЕ НА НЕГО (то есть используете одни заглавные буквы).

Он отвечает <<Calm down, I know what I'm doing!>> на вопрос, в котором вы кричите.

Он говорит <<Fine. Be that way!>> если вы обращаетесь к нему, но ничего
не говорите (это значит, что входная строка программы состоит из пробельных символов).

Он говорит <<Whatever.>> во всех остальных случаях.

Напишите диалоговую программу, которая имитирует разговор с Бобом. На каждую входную строку она
должна выводить такой ответ, какой давал бы Боб в такой же ситуации. Входные реплики для программы
должны подчиняться правилам пунктуации английского языка.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Каким способом проверяется, что все буквы во введённой строке заглавные?
    \item Какую функцию стандартной библиотеки можно использовать для проверки пробельных символов?
\end{itemize}

\section{Crypto square}

Implement the classic method for composing secret messages called a square code.

Given an English text, output the encoded version of that text.

First, the input is normalized: the spaces and punctuation are removed from the English text and the message is downcased.

Then, the normalized characters are broken into rows. These rows can be regarded as forming a rectangle when printed with intervening newlines.

For example, the sentence

"If man was meant to stay on the ground, god would have given us roots."
is normalized to:

"ifmanwasmeanttostayonthegroundgodwouldhavegivenusroots"
The plaintext should be organized in to a rectangle. The size of the rectangle (r x c) should be decided by the length of the message, such that c >= r and c - r <= 1, where c is the number of columns and r is the number of rows.

Our normalized text is 54 characters long, dictating a rectangle with c = 8 and r = 7:

"ifmanwas"
"meanttos"
"tayonthe"
"groundgo"
"dwouldha"
"vegivenu"
"sroots  "

The coded message is obtained by reading down the columns going left to right.

The message above is coded as:

"imtgdvsfearwermayoogoanouuiontnnlvtwttddesaohghnsseoau"
Output the encoded text in chunks that fill perfect rectangles (r X c), with c chunks of r length, separated by spaces. For phrases that are n characters short of the perfect rectangle, pad each of the last n chunks with a single trailing space.

"imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn  sseoau "
Notice that were we to stack these, we could visually decode the ciphertext back in to the original message:

"imtgdvs"
"fearwer"
"mayoogo"
"anouuio"
"ntnnlvt"
"wttddes"
"aohghn "
"sseoau "

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item
\end{itemize}

\section{Подстроки}

Given a string of digits, output all the contiguous substrings of length n in that string in the order that they appear.

For example, the string "49142" has the following 3-digit series:

"491"
"914"
"142"
And the following 4-digit series:

"4914"
"9142"
And if you ask for a 6-digit series from a 5-digit string, you deserve whatever you get.

Note that these series are only required to occupy adjacent positions in the input; the digits need not be numerically consecutive.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item
\end{itemize}

\chapter{Алгоритмы}

\section{Сортировка}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item
\end{itemize}

\section{Двоичный поиск}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item
\end{itemize}

\section{std::accumulate}

Переделайте функции {\tt sum} в программах из задания~\ref{array-value},
используя алгоритм {\tt std::accumulate}.
Для этого потребуется подключить заголовочный файл {\tt numeric}.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Как переделать вызов {\tt std::accumulate}, чтобы вычислялась сумма элементов
          из первой половины массива?
\end{itemize}

\section{Снова std::accumulate}

Переделайте программы из предыдущего задания, чтобы вместо суммы функция {\tt std::accumulate} считала
произведение элементов.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Какое значение должно получиться, если в массиве не будет ни одного элемента?
\end{itemize}

\chapter{Структуры данных}

\section{Кольцевой буфер}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item
\end{itemize}

\chapter{Хеширование}

\section{Анаграммы}

An anagram is a rearrangement of letters to form a new word.
Given a word and a list of candidates, select the sublist of anagrams of the given word.

Given "listen" and a list of candidates like "enlists" "google" "inlets" "banana"
the program should return a list containing "inlets".

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item
\end{itemize}

\section{Анаграммы 2}

Найти все анаграммы из слов-кандидатов для всех подмножеств букв из исходного слова.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item
\end{itemize}

\chapter{std::map}

\section{Поиск}

Перепишите следующую программу, используя {\tt std::map}.

Выполните следующие действия:
\begin{itemize}
    \item Замените массивы {\tt word} и {\tt def} на переменную-контейнер {\tt std::map}.
    \item Замените алгоритм поиска на функцию {\tt find} контейнера {\tt std::map}.
\end{itemize}

\lstinputlisting{sources/map1.cpp}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Что делает исходная программа?
    \item Какой тип ключа применяется в использованном контейнере {\tt std::map}?
    \item Что возвращает функция {\tt find}, если нужный элемент не найден?
\end{itemize}

\section{Подсчёт слов}

Напишите программу, которая выводит сколько раз каждое слово из входной строки повторяется в ней.

Слова могут состоять из цифр и латинских букв. Слова с разным регистром букв считаются одинаковыми.
Знаки препинания, пробелы, переносы строк и символы табуляции нужно игнорировать.

\subsection*{Подзадачи}

\begin{itemize}
    \item Используйте {\tt std::map<std::string, int>} для хранения информации о количестве повторов.
    \item Попробуйте не считывать весь текст целиком, а читать по одному символу из входного потока.
    \item Напишите два варианта программы: с преобразованием хранимых в {\tt std::map} слов и без него.
          Для второго варианта замените функцию сравнения (третий параметр шаблона) на собственную.
\end{itemize}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Определён ли порядок элементов в {\tt std::map}? Можно ли его изменить?
\end{itemize}

\end{document}
